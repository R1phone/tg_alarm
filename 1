// index.js - Cloudflare Worker (Scheduled)
export default {
  async scheduled(event, env, ctx) {
    ctx.waitUntil(handleScheduled(env));
  },
};

const KEY_ALERT = "tg_alert_state";

// !!! ПОДСТАВЬ СВОИ СЕКРЕТЫ В ENV !!!
const ENV = {
  MATTERMOST_WEBHOOK: "<Вставь сюда свой Mattermost Webhook>",
  BOT_TOKEN: "<Вставь сюда свой Telegram BOT_TOKEN>",
  TEST_CHAT_ID: "<Вставь сюда chat_id, если хочешь тестовые сообщения>",
  MIN_CONSECUTIVE_FAILURES: 2,
  CHECK_HOST_MAX_NODES: 5,
  CHECK_HOST_FAIL_NODES: 2
};

function short(s, n) { if (!s) return ""; return s.length > n ? s.slice(0,n-1) + "…" : s; }
function stripTags(html) { return (html||"").replace(/<script[\s\S]*?<\/script>/gi,"").replace(/<style[\s\S]*?<\/style>/gi,"").replace(/<\/?[^>]+(>|$)/g,""); }

async function sendMattermost(webhook, text) {
  if (!webhook) return;
  const payload = { username: "tg-monitor", icon_url: "https://telegram.org/img/t_logo.png", text };
  try { await fetch(webhook, { method: "POST", headers: { "Content-Type":"application/json" }, body: JSON.stringify(payload) }); }
  catch(e){ console.log("Failed to post to Mattermost:", e);}
}

async function handleScheduled(env) {
  const now = Date.now();
  const results = [];
  const signals = [];

  // 1) HARD: getMe
  let apiGetMeOk = false;
  const botToken = ENV.BOT_TOKEN;
  if (!botToken) { results.push("BOT_TOKEN missing"); signals.push({source:"getMe",problem:true}); }
  else {
    const getMeUrl = `https://api.telegram.org/bot${botToken}/getMe`;
    try {
      const r = await fetch(getMeUrl);
      const j = await r.json().catch(()=>null);
      if(r.ok && j && j.ok) { apiGetMeOk=true; results.push("getMe OK"); signals.push({source:"getMe",problem:false}); }
      else { results.push("getMe FAIL"); signals.push({source:"getMe",problem:true}); }
    } catch(e){ results.push(`getMe ERROR: ${e}`); signals.push({source:"getMe",problem:true}); }
  }

  // 2) Multi-location check (check-host.net)
  let multiFail=false;
  try {
    const hostParam = encodeURIComponent("https://api.telegram.org");
    const r = await fetch(`https://check-host.net/check-http?host=${hostParam}&max_nodes=${ENV.CHECK_HOST_MAX_NODES}`);
    const j = await r.json();
    const requestId = j.request_id;
    const res = await fetch(`https://check-host.net/check-result-extended/${requestId}`);
    const resj = await res.json();
    let failCount=0;
    for(const node of Object.values(resj.results||{})){
      if(Array.isArray(node)&&node[0][0]!==1) failCount++;
    }
    multiFail = failCount>=ENV.CHECK_HOST_FAIL_NODES;
    results.push(`check-host nodes fail=${failCount}`); signals.push({source:"check-host",problem:multiFail,detail:`fail=${failCount}`});
  } catch(e){ results.push("check-host ERROR");}

  // 3) web.telegram.org quick fetch
  let webFails=0;
  const webTargets=["https://web.telegram.org/","https://telegram.org/"];
  for(const url of webTargets){
    try{ const r=await fetch(url); if(!r.ok){webFails++; signals.push({source:url,problem:true});}else{signals.push({source:url,problem:false});} }catch(e){ webFails++; signals.push({source:url,problem:true}); }
  }

  // 4) (optional) sendMessage test
  let sendFail=false;
  if(ENV.TEST_CHAT_ID){
    try{
      const r=await fetch(`https://api.telegram.org/bot${botToken}/sendMessage`, { method:"POST", headers:{"Content-Type":"application/json"}, body:JSON.stringify({chat_id:ENV.TEST_CHAT_ID,text:"tg-monitor test"})});
      const j=await r.json().catch(()=>null);
      if(!r.ok||!j||!j.ok){ sendFail=true; signals.push({source:"sendMessage",problem:true});} else {signals.push({source:"sendMessage",problem:false});}
    }catch(e){sendFail=true; signals.push({source:"sendMessage",problem:true});}
  }

  // DECISION
  const shouldAlert = !apiGetMeOk || (multiFail && (webFails>0 || sendFail));

  // KV state
  let state=null;
  try{ const raw = await ENV.STATUS_KV.get(KEY_ALERT); state=raw?JSON.parse(raw):null;}catch(e){state=null;}
  const prevAlert=state&&state.alerting;
  let consecutiveFails=state&&state.consecutiveFails?state.consecutiveFails:0;
  consecutiveFails=shouldAlert?consecutiveFails+1:0;
  const willAlert=consecutiveFails>=ENV.MIN_CONSECUTIVE_FAILURES;

  // send alert / recovery
  if(willAlert&&!prevAlert){
    const text=["**⚠️ Telegram outage detected**",`Detected at: ${new Date(now).toISOString()}`];
    for(const s of signals) text.push(`• ${s.source}: ${s.problem?"PROBLEM":"ok"}`);
    await sendMattermost(ENV.MATTERMOST_WEBHOOK,text.join("\n"));
    await ENV.STATUS_KV.put(KEY_ALERT,JSON.stringify({alerting:true,since:now,consecutiveFails}));
    return;
  }
  if(!willAlert&&prevAlert){
    const text=["**✅ Telegram recovered**",`Recovered at: ${new Date(now).toISOString()}`];
    for(const s of signals) text.push(`• ${s.source}: ${s.problem?"PROBLEM":"ok"}`);
    await sendMattermost(ENV.MATTERMOST_WEBHOOK,text.join("\n"));
    await ENV.STATUS_KV.put(KEY_ALERT,JSON.stringify({alerting:false,since:now,consecutiveFails}));
    return;
  }
  await ENV.STATUS_KV.put(KEY_ALERT,JSON.stringify({alerting:prevAlert||false,since:state&&state.since?state.since:now,consecutiveFails}));
}
